#  考研-计算机操作系统

>   重点使用 [重点] 进行标记  计算使用[计算]进行标记 未完成使用[未完成]标记 未懂用[未懂]标记

## 目录

-   <a href="#p1">操作系统引论</a>
-   <a href="#p2">进程的描述与控制</a>
-   <a href="#p3">处理机调度与死锁</a>
-   <a href="#p4">存储器管理</a>
-   <a href="#p5">虚拟存储器</a>
-   <a href="#p6">输入输出系统</a>
-   <a href="#p7">文件管理</a>
-   <a href="#p8">磁盘存储器管理</a>
-   <a href="#p9">操作系统接口</a>
-   <a href="#p10">多处理器操作系统</a>
-   <a href="#p11">多媒体操作系统</a>
-   <a href="#p12">保护和安全</a>



## 知识点

-   <span name="p1">第一章 操作系统引论</span> 
    -   操作系统的目标和作用
        -   目标: 方便性 有效性 可扩充性 开放性
        -   作用: 作为用户和计算机硬件系统之间的接口 计算机系统资源的管理者 实现对计算机资源的抽象
    -   操作系统的发展过程
        -   未配置操作系统的计算机系统: 人工操作模式 脱机输入/输出方式
        -   单道批处理系统: 
            -   处理过程:
                ![image-20210120212227236](考研-计算机操作系统.assets/image-20210120212227236.png)
            -   缺点: 资源得不到充分利用 [计算]
                ![image-20210120214442771](考研-计算机操作系统.assets/image-20210120214442771.png)
        -   多道批处理系统
            -   多道程序设计基本概念: 用户将程序放入外存形成后备队列,有作业调度程序按一定算法进行调度进入内存,共享CPU等资源
                ![image-20210120214855376](考研-计算机操作系统.assets/image-20210120214855376.png)
            -   优缺点: 资源利用率高 系统吞吐量大 平均周转事件长 无交互能力
            -   需要解决的问题: 处理机争用问题 内存分配和保护 I/O设备分配 文件组织和管理 作业管理 用户与系统的接口交互
        -   分时系统
            -   引入: 满足用户对人机交互的需求  人机交互 共享主机(允许多个用户同时有自己的终端)
            -   关键问题: 
                -   及时接收(使用多路卡可以实现分时多路复用 每一个终端配置一个缓冲区,暂存用户输入) 
                -   及时处理(作业直接进入内存 采用轮转运行方式 为避免一个作业长期占用处理机,引入时间片概念)
            -   特征: 多路性 独立性 实时性 交互性
        -   实时系统
            -   使用例子: 工业(武器)控制系统 信息查询系统 多媒体系统 嵌入式系统
            -   实时任务类型: 周期性和非周期性任务(两者都有截止时间) 硬实时任务(明确截止时间绝对不能超过)和软实时任务(有截止时间,尽量不要超过)
            -   和分时系统的比较(多路性 独立性 及时性 交互性 可靠性 等)
        -   微机操作系统发展[略]
    -   操作系统基本特征 [重点]
        -   并行
            -   并行指两个或多个事件在同一时刻发生(同时发生) 并发是指两个或多个事件在同一时间间隔内发生(可以不同时发生)
            -   进程: 
                -   进程是在系统中能独立运行并作为资源分配的基本单位 由一组机器指令,数据和堆栈等组成 能够独立运行的活动实体 
                -   进程是现在操作系统最重要的基本概念 多个进程之间可以并发执行和交换信息
        -   共享
            -   互斥共享方式 在一段时间内只允许一个进程访问的资源,称为"临界资源"
            -   同时共享方式 宏观是同时访问 微观上是进程对资源进行交替访问
        -   虚拟
            -   时分复用技术 空分复用技术
        -   异步
            -   进程不是一步完成,走走停停
        -   注意: 并行和共享是多用户操作系统的两个最基本特征
    -   操作系统主要功能
        -   处理机管理功能: 进程控制(作业分配进程和资源及管理) 进程同步(进程互斥方式 进程同步方式) 进程通信(进程间信息交换) 调度(作业调度 进程调度)
        -   存储器管理: 内存分配(为程序分配内存空间 提高存储器利用率 程序申请附加内存 分为静态和动态分配方式) 内存保护 地址映射 内存扩充(请求调入 置换功能)
        -   设备管理功能: 缓冲管理 设备分配 设备处理
        -   文件管理功能: 文件存储空间管理 目录管理 文件读写管理和保护
        -   操作系统与用户接口: 用户接口 程序接口
        -   现代操作系统新功能 [略]
    -   OS结构设计 [略]
    
-   <span name="p2">第二章 进程的描述与控制</span> 
    -   前趋图和程序执行
        -   前趋图
            -   前趋图是指一个有向无循环图(DAG,Directed Acyclic Graph) 
            
            -   前趋图用于描述进程之间的先后顺序 每一个结点表示一个进程或程序段甚至一条语句 结点之间的有向边表示结点之间的偏序或前趋关系 
            
                ![image-20210121004214093](考研-计算机操作系统.assets/image-20210121004214093.png)
                ![image-20210121004238772](考研-计算机操作系统.assets/image-20210121004238772.png)
            
        -   程序顺序执行
        
            -   程序顺序执行下的前趋图
                ![image-20210121015459780](考研-计算机操作系统.assets/image-20210121015459780.png)
            -   顺序执行的特征
                -   顺序性: 处理机严格按照程序规定顺序执行 即在下一个操作开始之前结束
                -   封闭性:程序在封闭环境下运行,程序运行独占整机资源 资源状态(除初始状态)只有本程序才可以改变,程序一旦执行,结果不受外界因素影响
                -   可再现性: 只要程序执行时的环境和初始条件相同,程序重复执行结果一致 (不论是否异步)
        
        -   程序的并发执行
        
            -   只有在不存在前趋关系的程序之间才有可能并发执行
                ![image-20210121020120219](考研-计算机操作系统.assets/image-20210121020120219.png)
            -   程序并发特征
                -   间断性(资源相互制约导致程序有暂停) 失去封闭性(系统存在多个可并发程序时,系统资源将共享) 不可再现性(因为失去封闭性)
        
    -   进程的描述

        -   进程定义和特征
            -   进程的多种定义
                -   进程是程序的一次执行 (进程是动态的 程序是静态的)
                -   进程是一个程序机器数据在处理机上顺序执行所发生的活动
                -   进程是具有独立功能的程序在一个数据集合上运行的过程,是系统进行资源分配调度的一个独立单位
            -   进程控制块(PCB, Process Control Block): 为进程配置的一个专门的数据结构,来描述进程的基本情况和活动过程,进而控制和管理进程
            -   程序段,相关数据段和PCB三部分构成进程实体(也称进程映像,简称进程) 创建进程即创建进程PCB,撤销进程实际上就是撤销进程PCB
            -   进程的特征: 动态性(程序只是有序指令的集合,进程有一定生命周期) 并发性 独立性(进程是系统调度基本单位) 异步性(异步方式运行)
        -   进程的基本状态及转换
            -   进程的三种基本状态
                -   就绪状态: 指进程已处于准备好运行的状态,等待CPU资源即可运行的状态 (系统按一定策略将许多就绪状态的进程排列为就绪队列)
                -   执行状态: 指进程已经获得CPU正在执行的状态 (单处理机中,只有一个进程处于执行状态,多处理机可以有多个进程处于执行状态)
                -   阻塞状态: 正在执行的进程由于发生某事件暂时无法继续执行的状态 (系统按一定策略将许多阻塞状态的进程排列为阻塞队列)
            -   三种基本状态的转换 [重要]
                ![image-20210121021947661](考研-计算机操作系统.assets/image-20210121021947661.png)
            -   创建状态和终止状态
                -   为满足PCB对数据和操作的完整性和灵活性要求,引入两种常见状态: 创建状态和终止状态 (形成五种状态的转换)
                    ![image-20210121022008752](考研-计算机操作系统.assets/image-20210121022008752.png)
                -   创建状态: 进程插入就绪队列过程中遇到所需资源尚不能得到满足,则创建过程尚未完成,进程无法正常调度运行,此时则为创建状态
                -   终止状态: 进程到达自然结束或出现无法客服的错误或被操作系统和其他有中止权的进程所终结,此时进程将进入终止状态,不再执行
        -   挂起操作和进程状态的转换
            ![image-20210121223709216](考研-计算机操作系统.assets/image-20210121223709216.png)
            -   引入原因: 
                -   终端用户的需要: 用户希望暂停程序运行,一边用户研究执行情况或者进行修改
                -   父进程请求: 父进程希望挂起子进程以便考查和修改子进程或者协调父子进程的活动
                -   负荷调节需要: 当实时系统种工作负荷较重以至于可能影响到对实时任务的控制时,可以将一些不重要进程挂起以保证系统正常运行
                -   操作系统需要: 操作系统希望挂起进程以检查资源情况或记账
            -   引入挂起原语Suspend和激活原语Active后进程状态的转换:
                -   活动就绪->静止就绪 就绪状态下默认为Readya,可以接收调度,经挂起到状态Readys,不可被调度执行
                -   活动阻塞->静止阻塞 当进程处于未被挂起就绪状态(活动就绪,Blockeda),当被挂起后则称为静止阻塞状态(Blockeds) 当所期待的事件发生后,将由静止阻塞变为静止就绪(Readys)状态
                -   静止就绪->活动就绪 处于进制就绪状态(Readys)进程用Active原语进行激活则转变为Readya状态
                -   静止阻塞->活动阻塞 处于静止阻塞状态(Blockeds)进程用Active原语进行激活则转变为Blockeda状态
            -   拥有创建/终止/挂起状态的进程转换
                -   Null->创建 一个进程产生的时候,该进程处于创建状态
                -   创建->活动就绪 当前系统条件允许,完成对进程创建必要操作后,进程进入就绪队列,处于活动就绪状态
                -   创建->静止就绪 系统条件未满足进程创建,系统将进程转换为静止就绪状态,安置在外存,不参与调度,创建工作没有完成
                -   执行->终止 进程完成任务或出现无法克服的错误或被系统或其他进程终结时,进程将状态改为终止状态
        -   进程管理中的数据结构
            -   操作系统中用于管理的数据结构
                -   主要分为4类: 内存表 设备表 文件表 用于进程管理的进程表(通常又称为进程控制块PCB)
                    ![image-20210121224004770](考研-计算机操作系统.assets/image-20210121224004770.png)
                -   进程控制块PCB的作用
                    -   作为独立运行基本单位的标志
                    -   能实现间断的运行方式 在多道程序环境下,程序异步性间断运行.当阻塞而暂停时,需要保存CPU现场信息
                    -   提供进程管理所需要的信息 操作系统总是根据PCB实施对进程的管理
                    -   提供进程调度所需要的信息 PCB中提供进程何时处于何种状态的信息
                    -   实现与其他进程的同步和通信 PCB进程中还具有用于实现进程通信的区域或者通信队列指针
                -   进程控制块PCB包含的信息
                    -   进程标识符: 外部标识符(由创建者提供 通常字母+数字组合) 内部标识符(每一个进程唯一的数字标识符)
                    -   处理机状态
                    -   进程调度信息
                    -   进程控制信息
                -   进程控制块PCB组织方式: 线性方式 链接方式 索引方式
        
    -   进程控制

        -   操作系统内核
            -   支撑功能: 中断处理 时钟管理 原语操作
            -   资源管理功能: 进程管理 存储器管理 设备管理
        -   进程层次结构: 操作系统允许一个进程(父进程)创建另一个进程(子进程) 众多进程合成一个进程家族(组)
            -   进程图: 为形象描述一个进程的家族关系引入进程图的概念: 由进程Pi指向进程Pj的有向边表明父子关系
                ![image-20210121225830138](考研-计算机操作系统.assets/image-20210121225830138.png)
        -   进程创建  [重要]
            -   创建条件: 系统每当出现创建新进程的请求,系统调用创建原语Create创建新进程
            -   引起进程创建的事件
                -   用户登陆 作业调度 提供服务 应用请求
            -   创建过程
                -   申请空白PCB,为进程获得唯一数字标识符(内部标识符) ,从PCB集合中索取一个空白PCB
                -   为新进程分配运行所需的资源 资源从操作系统或者父进程中获取
                -   初始化进程控制块PCB: 初始化标识信息 初始化处理机状态信息 初始化处理机控制信息
                -   将新进程放入就绪队列
        -   进程终止
            -   终止条件
                -   进程正常结束: 进程任务完成,准备退出运行
                -   异常结束: 越界错误 保护错误 非法指令 特权指令错误 运行超时 等待超时 运算错误 
                -   外界干预: 操作系统或操作员干预 父进程请求终止 父进程终止(也会引起子进程终止)
            -   终止过程
                -   检索进程的进程控制块PCB,读出进程状态
                -   如果进程正在被执行则立即终止并在终止后重新进行调度
                -   停止子孙进程
                -   资源归还给父进程或者系统
                -   将终止进程的PCB从所在队列或者链表中移出,等待后续处理
        -   进程的组合与唤醒 [未完成]
        -   进程的挂起与激活 [未完成]

    -   进程同步 [掌握四个原则]

        -   进程同步概念

            -   两种形式的制约关系: 

                -   间接相互制约关系(系统共享资源,多个进程只能互斥使用)
                -   直接相互制约关系(为完成某任务建立多个进程为完成同一任务而相互合作而受制约)

            -   临界资源

                ```java
                public class Test {		// 书上P49
                    // in输入指针的位置 out输出指针的位置 count缓冲队列当前大小
                	int in = 0, out = 0, count = 0; 	    // count应该成为临界资源(现在并没有)
                    // 用于存放的缓冲区 大小为n
                	item buffer[n];
                
                	void producer() {					  // 生产者
                		while (1){
                            produce an item in nextp;		// 生产者生产一个商品放入nextp队列
                            ...					
                            while (counter == n) ;			// 等待缓冲区非满
                            buffer[in] = nextp;			    // 放入缓冲区
                         	in = (in + 1) % n;			    // 输入指针后移 缓冲区为循环缓冲区
                            count++;					   // 缓冲区当前数量增加1
                		}
                	}
                    
                    void consumer(){
                        while(1){
                            while(count == 0) ;				// 如果缓冲队列为空则等待
                            nextc = buffer[out];			// 获取缓冲队列输出指针位置的item
                            out = (out + 1) % n;			// 获得下一个输出指针
                            count--;					   // 缓冲区当前数量减1
                            ...
                        }
                	}
                }
                
                ```

                

            -   临界区: 进程对系统临界资源必须互斥访问,每个进程中访问临界资源的代码称为临界区

                -   临界区前有进入区 临界区后有退出区

                -   临界区划分: 

                    ```java
                    while(True){
                        进入区 
                        临界区
                        退出区
                        剩余区
                    }
                    ```

            -   同步机制应该遵循的规则 [重要]

                -   空闲让进 当无进程处于临界区时(临界区空闲),应允许一个请求进入临界区的进程立即进入临界区
                -   忙则等待 当有进程进入临界区(临界区正在被访问),其他进程必须等待以实现对临界资源的互斥访问
                -   有限等待 对要求访问临界资源的进程,应保证在有限时间内能进入而避免陷入"死等"状态
                -   让权等待 当进程不能进入自己的临界区时,应该立即释放处理机,以免进程进入"忙等"状态

        -   硬件同步机制

            -   关中断

                -   实现互斥最简单方法之一 在进入锁之前关闭中断在完成锁开中断避免引发调度等进线程切换操作

            -   利用TS(Test-and-Set)指令实现互斥

                -   许多计算机都是用这个方式 这个过程是不可分割(也就是一条原语)

                -   指令如下 (*lock为FALSE表示资源空闲,反之为忙碌)

                    ```java
                    boolean TS(boolean *lock){
                        boolean old;
                        old = *lock;
                        *lock = TRUE;
                        return old;
                    }
                    ```

                -   使用上述指令的代码

                    ```java
                    do{
                        ...
                    	while TS(&lock) ; 	// 跳过
                        critical section;
                        lock = FALSE;
                        remainder section;
                    } while (TRUE)
                    ```

            -   利用Swap指令实现进程互斥

                -   该指令又称为对换指令,实现如下 用于交换两个字的内容

                    ```java
                    void swap(boolean *a, boolean *b){
                        boolean temp;
                        temp = *a;
                        *a = *b;
                        *b = temp;
                    }
                    ```

                -   利用Swap指令实现进程互斥描述如下

                    ```java
                    do{
                        key = TRUE;
                        do {
                            swap(&lock, &key);
                        } while (key != FALSE);
                        临界区操作...
                        lock = FALSE;
                        ...
                    } while(TRUE);
                    ```

        -   信号量机制: 广泛使用 [重要]

            -   整型信号量: 

                -   整型信号量定义为用于表示资源数目的整型量S

                -   除初始化外,只能通过标准原子操作wait和signal访问,这两个操作也被称为P/V操作

                -   wait和signal描述如下

                    ```java
                    wait (S){
                        while (S <= 0);		// 存在忙等的状态 不符合"让权等待"的准则
                        S--;
                    }
                    signal (S){
                        S++;
                    }
                    ```

            -   记录型信号量

                -   在信号量机制中,不存在"忙等"现象的进程同步准则 除了需要代表资源数目的整型变量value外,还需要进程链表指针list,用于链接所有等待进程

                -   记录型信号量描述如下

                    ```java
                    typedef struct{
                        int value;
                        struct process_control_block *list;		// 定义了一个PCB
                    } semaphore;
                    ```

                -   相应的wait和signal描述如下

                    ```java
                    wait(semaphore *S){
                        S->value--;
                        if (S->value < 0) block(S->list);		// 如果资源不足则阻塞,放弃处理机
                    }
                    signal(semaphore *S){
                        S->value++;
                        if(S->value <= 0) wakeup(S->list);		// 如果资源增加,则唤醒第一个等待进程
                    }
                    ```

            -   AND型信号量 [略]

            -   信号量集 [略]

        -   信号量应用

            -   利用信号量实现进程互斥

                -   为实现多个进程实现互斥访问资源,只需要为资源设置互斥信号量mutex=1,然后将各进程访问该资源的临界区设置wait和signal操作即可

                -   设置mutex为互斥信号量,取值范围为[-1, 0, 1],分别表示:有一个进程正在临界区运行另一个等待而阻塞,当前一个进程完成则进入临界区运行;有一个进程进入临界区另一个等待,挂入阻塞队列;两个进程都没有进入需要互斥的临界区.

                    ```java
                    semaphore mutex = 1;
                    Pa(){
                        while (1){
                            wait(mutex);
                            临界区
                            signal(mutex);
                            剩余区
                        }
                    }
                    Pb(){
                        while (1){
                            wait(mutex);
                            临界区
                            signal(mutex);
                            剩余区
                        }
                    }  
                    ```

                -   wait和signal操作必须成对出现,缺少wait则不能保证临界资源互斥访问,缺少signal则资源永不释放

            -   利用信号量实现前趋关系

                -   给不同的进程定义不同的信号量,实现前趋关系(见图)
                    ![image-20210122155215930](考研-计算机操作系统.assets/image-20210122155215930.png)

                    ```java
                    P1(){S1; signal(a); signal(b);}
                    P2(){wait(a); S2; signal(c); signal(d);}
                    P3(){wait(b); S3; signal(e);}
                    P4(){wait(c); S4; signal(f);}
                    P5(){wait(d); S5; signal(g);}
                    P6(){wait(f); wait(g); wait(e); S6;}
                    main(){
                        semaphore a, b, c, d, e, f, g;
                        a.value = b.value = c.value = d.value = e.value = f.value = g.value = 0;
                        cobegin		// cobegin和coend之间可以并发运行
                            p1(); P2(); P3(); P4(); P5(); P6();
                        coend
                    }
                    ```

            -   管程机制 [略]

        -   经典进程同步问题

            -   生产者-消费者问题 [利用AND信号量和管程机制解决该问题 略]

                -   假定在生产者和消费者之间的共用缓冲池中有n个缓冲区,这时可以利用互斥信号量mutex实现诸进程对缓冲区的互斥使用,利用empty和full标记缓冲池中的空缓冲区和满缓冲区数量,只要缓冲池未空则可以取出,未满则可以放入

                    ```java
                    int in = 0, out = 0;
                    item buffer[n];		//假设有一个大小为n的缓冲区
                    semaphore mutex = 1, empty = n, full = 0;
                    
                    void producer(){		// 生产者
                        do{
                            producer an item into nextp;
                            ...
                            wait(empty);		// 判断是否有空
                            wait(mutex);		// 请求访问权限
                            buffer[in] = nextp;		// 放入缓冲区
                            in = (in + 1) % n;		// 调整指针位置
                            signal(mutex);		// 释放访问权限
                            signal(full);		// 提示缓冲区多一个
                        } while(TRUE);
                    }
                    
                    void consumer(){		// 消费者
                        do{
                            wait(full);
                            wait(mutex);
                            nextc = buffer[out];		// 取出输出指针位置指向的量
                            out = (out + 1) % n;		// 计算下一个指针位置
                            signal(mutex);
                            signal(empty);
                        } while(TRUE);
                    }
                    
                    void main(){
                        cobegin
                            producer(); consumer();
                        coend
                    }
                    ```

                -   wait和signal操作必须成对出现,wait的顺序不可以颠倒,否则可能会引起进程死锁

            -   哲学家进餐问题

                -   桌子上筷子为临界资源 需要实现筷子的互斥使用,可以用一个信号量表示一只筷子 信号量构成一个数组
                -   解决代码如下;

                    ```java
                    semaphore chopstick[5] = {1, 1, 1, 1, 1};
                    
                    // 描述第i位哲学家活动
                    do{
                        wait(chopstick[i]);
                        wait(chopstick[(i + 1) % 5]);
                        ...
                        eat;		// 哲学家进行吃饭
                        ...
                        signal(chopstick[i]);
                        signal(chopstick[(i + 1) % 5]);
                        ...
                        think;		//  哲学家进行思考
                        ...
                    } while(TRUE);
                    ```

                -   当哲学家饿时则会先那左边筷子再拿右边筷子,成功便会进行就餐 但是存在死锁问题
                
                    -   解决方法: 最多只允许4个哲学家同时拿筷子 / 仅左右筷子都均可用才可用餐 / 规定奇数哲学家拿左边筷子偶数哲学家拿右边筷子

            -   读者-写者问题

                -   用记录型信号量机制解决
                    
                    -   为实现读写互斥设置互斥信号量wmutex,readcount表示正在读的进程数,仅当readcount=0(没有read进程)才执行wait(wmutex)操作
                    
                    -   代码描述如下
                    
                        ```java
                        semaphore rmutext = 1, wmutex = 1;
                        int readcount = 0;
                        
                        void reader(){
                            do{
                                wait(rmutex);							// 获取读访问权限
                                if(readcount == 0) wait(wmutex);		// 如果没有正在读则reader进程开始读 需要改变读标志
                                readercount++;
                                signal(rmutex);							// 释放读访问权限
                                ... ;
                                perform read operation;					// 执行读操作
                                ... ;
                                wait(rmutex);							// 结束的时候 获取读访问权限
                                readcount--;
                                if(readcount == 0) signal(wmutex);		// 如果没有正在读进程则修改读标志
                            } while (TRUE);
                        }
                        
                        void writer(){
                            do{
                                wait(wmutex);							// 等待读权限
                                perform write operation;				// 执行写操作
                                signal(wmutex);							// 释放读权限
                            } while (TRUE);
                        }
                        
                        void main(){
                            cobegin
                                reader(); writer();
                            coend
                        }
                        ```
                    
                -   用信号量集机制解决 [未懂]
                
                    -   在之前基础上增加了最大同时读数量,并引入信号量L(初值为RN),通过wait(L, 1, 1)来控制读者数目
                
                    -   代码描述如下
                
                        ```java
                        int RN;
                        semaphore L = RN, mx = 1;
                        
                        void reader(){
                            do{
                                swait(L, 1, 1);
                                swait(mx, 1, 0);
                                ... ;
                                perform read operation;
                                ... ;
                                ssignal(L, 1);
                            } while(TRUE);
                        }
                        
                        void writer(){
                            do{
                                swait(mx, 1, 1; L, RN, 0);
                                perform write operation;
                                ssignal(mx, 1);
                            } while(TRUE);
                        }
                        ```

        -   进程通信: 即进程之间的信息交换 大多为低级通信

            -   进程通信类型
                -   共享存储器系统 管道(pip)通信系统 消息传递系统 客户机-服务器系统
            -   消息传递通信实现方式 [略]

        -   线程(Threads)的基本概念: 线程是比进程更小的基本单位

            -   线程的引入
                -   进程基本属性:  进程是一个有资源的独立单位,同时又是可以独立调度和分派的基本单位  这两个属性构成进程并发执行的基础
                -   程序并发付出的时空开销: 创建进程 撤销进程 进程切换  因为要付出较大时空开销所以限制并发程度进一步提高
                -   线程: 作为调度和分派的基本的单位,不加以频繁切换
            -   线程和进程比较
                ![image-20210122221211463](考研-计算机操作系统.assets/image-20210122221211463.png)
            -   线程状态和线程控制块
                -   线程运行的三个状态 切换和进程切换类似
                    -   执行状态 线程拥有处理机并正在运行
                    -   就绪状态 线程具备条件只需要CPU便能立即执行
                    -   阻塞状态 线程因为某事件而处于暂停状态
                -   线程控制块: 为线程配备的用于控制和管理线程的控制块
                -   多线程OS中的进程属性:
                    -   进程是一个可拥有资源的基本单位
                    -   多个线程可以并发执行
                    -   进程已不是可执行的实体
        
        -   线程的实现 [略]
        ![image-20210122224447101](考研-计算机操作系统.assets/image-20210122224447101.png)
    
-   <span name="p3">第三章 处理机调度与死锁</span> 

    -   处理机调度的层次和调度算法的目标
        -   处理机调度层次
            -   高级调度: 又称为长调度或作业调度 调度对象是作业
            -   中级调度: 又称为内存调度 为提高内粗利用率和系统吞吐量
            -   低级调度: 又称为进程调度或短程调度 调度对象是进程
        -   处理机调度算法目标
            -   调度共同目标: 资源利用率 公平性 平衡性 策略强制执行
                -   资源利用率计算 [计算]: CPU利用率 = CPU有效工作时间 / (CPU有效工作时间+CPU空闲等待时间)
            -   批处理系统目标: 平均周转时间短 系统吞吐量高 处理机利用率高
            -   分时系统目标: 响应时间快 均衡性
            -   实时系统目标: 截止时间的保证 可预测性
    -   作业与作业调度
        -   批处理系统中的作业
            -   作业和作业步
                -   作业是比程序更为广泛的概念,包含了程序,数据以及作业说明书 批处理系统中以作业为单位调入内存
                -   作业步: 作业的每一个加工步骤称为一个作业步
            -   作业控制块(JCB, Job-Control-Block)
            -   作业运行的三个阶段(三个状态)
                -   收容状态(操作系统将作业通过某输入方式或者SPOOLing系统输入到硬盘并建立JCB,放入作业后备队列)
                -   运行阶段(作业被作业调度选中分配必要的资源和建立进程,并放入就绪队列,到它结束运行前)
                -   完成阶段(当作业运行完成或发生异常提前结束,作业将进入完成阶段)
            -   作业调度任务: 接纳数量 接纳种类
            -   先来先服务(FCFS)和短作业优先调度算法
                -   先来先服务算法(可以用于进程和作业调度)
                    -    不管作业长短,系统按照作业到达顺序的先后次序进行调度 当进程结束或者阻塞后将处理机分给别的进程
                -   短作业优先调度算法(SJF)
                    -   作业越短优先级越高,根据作业运行时间进行衡量
                    -   短作业优先算法缺点: 需要预知作业运行时间 对长作业不利 无法实现人机交互 未考虑作业紧迫程度
            -   优先级调度算法和高相应比调度算法
                -   优先级调度算法(PSA)
                    -   作业的等待时间就是优先级 等待时间越长,其优先级越高 但是同样也不能反映作业紧迫程度
                -   高相应比调度算法(HRRN) [计算]
                    -   优先级计算方法: 优先权(Rp) = (等待时间 + 要求服务时间) / 要求服务时间
                    -   响应时间 = 等待时间 + 要求服务时间
                    -   特点:
                        -    如果等待时间一样,要求服务时间短进程优先 
                        -   要求服务时间相同,优先级取决于等待时间 
                        -   长作业优先级根据等待时间而提高 也可以获得处理机
    -   进程调度
        -   进程调度的任务 机制和方式
            -   任务: 保存现场信息 按照某种算法选取进程 将处理机分配给进程
            -   机制: 排队器 分派器 上下文切换器
                ![image-20210123005442658](考研-计算机操作系统.assets/image-20210123005442658.png)
            -   调度方式: 非抢占方式 抢占方式
        -   轮转调度算法(PR算法)
            -   基本原理
                -   从就绪队列中取得第一个进程,经过一个时间片后或者运行完毕后将CPU分给下一个队首进程
            -   切换时机
                -   如果一个时间片内程序完成则立即激活调度程序,将它从就绪队列中删除.进行下一个进程的执行
                -   如果一个时间片结束则计时器中断程序激活,将程序暂停并放入就绪队列末尾,执行下一个进程
            -   时间片大小的确定
                -   如果时间片过小则会增加系统负担 如果时间片过大则算法演化为FCFS(先入先出)算法
                    ![image-20210123161111963](考研-计算机操作系统.assets/image-20210123161111963.png)
        -   优先级调度算法
            -   分类
                -   非抢占式优先级调度算法: 一旦把处理机分给进程,需要等进程发横某事件而放弃处理机,系统才将处理机重新分配
                -   抢占式优先级调度算法: 将处理机分给进程,当出现另一个优先级更高的进程,调度程序就把处理机分给新进程
            -   优先级类型
                -   静态优先级: 根据进程类型,进程对资源的需求,用户要求分配一个固定的优先级
                -   动态优先级: 在创建进程初赋予一个优先级,随着进程推进或者等待时间而改变
        -   多队列调度算法
        -   多级反馈队列调度算法
            -   调度机制
                ![image-20210123185822746](考研-计算机操作系统.assets/image-20210123185822746.png)
                -   设置多个就绪队列,每一个队列赋予不同优先级(依次降低),优先级越高,时间片越小
                -   每一个队列都是FCFS先进先出算法
                -   按照队列优先级进行调度 即仅当前一列未空下一列才开始调度
            -   调度算法性能
                -   如果规定第一个队列的时间片略大于多数人机交互所需要的时间片时,能够较好满足各种类型用户需要
        -   基于公平原则调度算法
            -   保证调度算法  公平分享调度算法
    -   实时调度 [略]
    -   死锁概述 [4个必要条件]
        -   资源问题
        -   计算机系统中的死锁
        -   死锁的定义 必要条件和处理方法 [重要]
            -   定义: 如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件,则称该组进程是死锁的
            -   必要条件 需要同时具备
                -   互斥条件 进程对所分配到的资源进行排他性使用 其他进程若要使用必须等待
                -   请求和保持条件 进程一个保持至少一个资源,但又提出新的请求
                -   不可抢占条件 进程已获得资源在未用完之前不可被抢占,只能在结束后释放
                -   循环等待条件 发生死锁必然存在一个进程-资源循环链
            -   处理方法: 预防死锁  避免死锁  检测死锁  解除死锁
    -   预防死锁: 破坏死锁需要的4个条件
    -   避免死锁
        -   系统安全状态
            -   系统处于安全状态可以避免死锁,如果处于不安全状态则可能进入到死锁状态
            -   存在一个安全序列使得系统可以按次序分配资源使每个进程都能顺利完成,则称系统是安全的
                ![image-20210124163059326](考研-计算机操作系统.assets/image-20210124163059326.png)
                ![image-20210124163127407](考研-计算机操作系统.assets/image-20210124163127407.png)
        -   利用银行家算法避免死锁 [重要]
            -   Dijkstra银行家算法,一开始为银行设计,避免发放贷款不会发现不满足需求的情况
            -   银行家算法中的数据结构
                -   可利用资源向量Available
                -   最大需求矩阵Max
                -   分配矩阵Allocation
                -   需求矩阵Need
            -   银行家算法
            -   安全性算法
            -   举例
                ![image-20210124162909492](考研-计算机操作系统.assets/image-20210124162909492.png)
    -   死锁的检测和解除 [未完成]
        -   检测: 资源分配图
        -   解除: 采取相应措施解除死锁 采用两种方法(抢占资源 终止/撤销进程)
            -   终止进程方法
            -   付出代价最小死锁解除法

-   <span name="p4">第四章 存储器管理</span> 

    -   存储器的层次结构
        -   多层结构存储器系统
            -   存储器多层结构
                -   通用寄存器存储层级至少包含三级: 最高层(CPU寄存器) 中间(主存储器) 最底层(辅助存储器)
                -   层次越高,速度越快,价格越高,容量越小
                -   计算机系统存储金字塔
                    ![image-20210126025542895](考研-计算机操作系统.assets/image-20210126025542895.png)
            -   可执行存储器: 寄存器和主存合称为可执行存储器 不同层次存储介质由系统统一管理
        -   主存与寄存器
        -   高速缓存和磁盘缓存
    -   程序的装入和链接: 程序在系统中运行需要经过几个步骤(编译,链接,装入)
        <img src="考研-计算机操作系统.assets/image-20210126030550750.png" alt="image-20210126030550750" style="zoom:50%;" />
        -   程序的装入
        -   程序的链接
    -   连续分配存储管理方式 [未完成]
        -   单一连续分配
            -   
        -   固定分区分配
        -   动态分区分配
        -   基于顺序搜索的动态分区分配算法
        -   基于索引搜索的动态分区分配算法 [略]
        -   动态可重定位分区分配
    -   对换Swapping
        -   
    -   分页存储管理方式
    -   分段存储管理方式

-   <span name="p5">第五章 虚拟存储器</span> 

    -   虚拟存储器概述 (如果出现了作业过大超过内存大小 或者 大量作业需要运行内存不足的情况)
        -   常规存储器管理方式的特征和局部性原理
            -   特征: 一次性(作业必须一次性装入内存后方可运行) 驻留性(作业装入后需要驻留内存至作业结束)
            -   局部性原理 (表现在时间局限性和空间局限性)
                -   程序执行时除了少数转移和过程调用指令,大多数顺序执行
                -   过程调用将会使程序的执行轨迹由一部分转为另一部分
                -   程序中由许多循环结构,只由少数指令构成但是会被多次执行
                -   程序包括许多对数据结构的处理,局限在很小范围
            -   虚拟存储器的基本工作原理
        -   虚拟存储器的定义和特征
            -   定义: 用户看到程序运行会以为程序全部都放入内存,其实并没有,这样的存储器称为虚拟存储器
            -   特征:
                -   多次性: 一个作业中的程序和数据无需在作业运行时一次性全部装入内存,而是分多次调入内存运行
                -   对换性: 程序无需在内存中一直常驻,允许在作业运行中换入或换出
                -   虚拟性: 指能够从逻辑上扩充内存容量,使用户能看到的内存容量大于内存实际容量(以前两者为基础)
            -   虚拟存储器实现方法
                -   分页请求系统
                -   请求分段系统
    -   请求分页存储器管理方式 [重点]
        -   请求分页中的硬件支持
            -   请求页表机制
            -   缺页中断机构
            -   地址变换机构
        -   请求分页中的内存分配
            -   最小物理量块数的确定
            -   内存分配策略
            -   物理块分配算法
        -   页面调度策略
        -   
    -   页面置换算法 (程序运行过程中,所要访问页面不在内存)
    -   "抖动"与工作集
    -   请求分段存储管理方式

-   <span name="p6">第六章 输入输出系统</span> 

    -   I/O系统的功能,模型和接口
    -   I/O设备和设备控制器
    -   中断机构和中断处理程序
    -   设备驱动程序
    -   与设备无关的I/O软件
    -   用户层I/O软件
    -   缓冲区管理
    -   磁盘存储器性能和调度

-   <span name="p7">第七章 文件管理</span> 

    -   文件和文件系统
    -   文件逻辑结构
    -   文件目录
    -   文件共享
    -   文件保护

-   <span name="p8">第八章 磁盘存储器管理</span>

    -   外存组织方式
    -   文件存储空间管理
    -   提高磁盘I/O速度的途径
    -   提高磁盘可靠性的技术
    -   数据一致性控制 

-   <span name="p9">第九章 操作系统接口</span>  [略] 

-   <span name="p10">第十章 多处理器操作系统 </span> [略] 

-   <span name="p11">第十一章 多媒体操作系统</span>  [略] 

-   <span name="p12">第十二章 保护和安全</span>  [略] 



## 课后习题

### 第一章

1.  设计现代OS主要目标是什么
2.  OS作用可以表现在哪些方面
3.  为什么收操作系统实现对计算机资源的抽象
4.  试说明推动多道批处理系统形成发展的主要动力
5.  何谓脱机I/O和联机I/O
6.  试说明推动分时系统形成和发展主要动力
7.  实现分时系统的关键问题是什么 如何解决
8.  为什么要引入操作系统
9.  什么是硬实时任务和软实时任务 举例说明
10.  试从交互性,及时性以及可靠性方面对比分时系统和实时系统
11.  OS有哪几大特征 基本特征是什么
12.  多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同 对独占资源采取何种共享方式
13.  什么是时分复用技术 举例说明能提高资源利用率的根本原因
14.  什么原因使系统具有异步性
15.  处理机管理有哪些主要功能 主要任务是什么
16.  内存管理有哪些主要功能 主要任务是什么
17.  设备管理有哪些主要功能 主要任务是什么
18.  文件管理有哪些主要功能 主要任务是什么
19.  试说明推动传统OS演变为现代OS的主要因素是什么
20.  什么是微内核OS
21.  微内核操作系统具有哪些优点
22.  现代操作系统相较传统操作系统增加哪些优点
23.  微内核OS为什么要采用C-S模式
24.  基于微内核结构OS应用哪些新技术
25.  何为微内核技术 微内核通常提供哪些功能

### 第二章

1.  什么是前趋图

2.  试画出下列语句的前趋图

    ```java
    S1: a = x + y;
    S2: b = z + 1;
    S3: c = a - b;
    S4: w = c + 1;
    ```

3.  为什么程序并发执行会产生间断特性

4.  程序并发执行为什么会失去封闭性和可再现性

5.  在操作系统中为什么要引入进程概念,会出现什么影响

6.  试从动态性 并发性 独立性上比较进程和程序

7.  试说明PCB的作用具体体现在哪些方面

8.  PCB提供了进程管理和进程调度所需要的哪些信息

9.  进程控制块的组织方式有哪些

10.  何为操作系统内核 内核的主要功能是什么

11.  试说明进程在三个基本状态之间切换的典型事件

12.  为什么要引入挂起状态 该状态有哪些性质

13.  在进行进程切换时,要保存处理机状态有哪些

14.  试说明引起进程创建的典型事件

15.  试说明进程撤销的典型事件

16.  在创建一个进程需要完成的任务是什么

17.  在撤销一个进程需要完成的任务是什么

18.  引起进程阻塞或者被唤醒的主要事件是什么

19.  为什么在OS中引入线程

20.  线程有哪些属性

21.  试从调度性 并发性 拥有资源情况 系统开销方面比较进程和线程

22.  线程控制块TCB包含哪些内容

23.  何为用户级线程和内核支持线程

24.  试说明用户级线程的实现方法

25.  试说明内核支持线程的实现方法

26.  多线程模型有哪几种类型,多对一模型有何特点

### 第三章

1.  高级调度与低级调度主要任务是什么 为何引入中级调度
2.  处理机调度算法共同目标是什么 批处理目标是什么
3.  何谓作业 作业步 作业流
4.  在什么情况下需要作业控制块JCB 包含什么内容
5.  在作业调度中应该如何确定接纳多少个作业和接纳哪些作业
6.  为什么引入高相应比优先调度算法 有何优点
7.  低级调度主要功能
8.  抢占调度方式中,抢占原则是什么
9.  选择调度方式和算法中,遵循的原则
10.  在批处理系统,分时系统和实时系统中,各采用几种作业调度算法
11.  何谓静态和动态优先级 确定静态优先级的依据
12.  比较FCFS先来先服务和SJF短进程优先调度算法
13.  在时间片轮转算法中,如何确定时间片大小
14.  举例说明优先级调度算法不适用于实时系统
15.  为什么说多级反馈队列能够较好满足各方面用户需求
16.  为何说传统几种调度算法无法算是公平调度算法
17.  如何保证调度算法的公平性
18.  公平分享调度算法如何做到公平性
19.  为什么实时系统中要求系统(特别是CPU)具有较强处理能力
20.  按调度方式可以将实时调度算法分为几种
21.  什么是最早截止时间优先调度算法,举例说明
22.  什么是最低松弛度优先调度算法,举例说明
23.  何为"优先级倒置"现象,用什么方式解决
24.  试分别说明可重用资源和可消耗资源的性质
25.  试举例说明竞争不可抢占资源所引起的死锁
26.  为破坏"请求和保持"条件提出两种协议,试比较这两种协议
27.  何为死锁,必要条件是什么
28.  死锁问题解决方式中哪种最容易实现,哪种方法资源利用率最高
29.  详细说明可通过哪些方式预防死锁
30.  如果P0进程发出请求向量中needs少了,系统可否将资源分配给它
31.  银行家算法中,若出现下列情况,问: 
     ![image-20210124162958651](考研-计算机操作系统.assets/image-20210124162958651.png)
     1.  该状态是否安全
     2.  如果P2提出Request[1,2,2,2],问系统可否将资源分配给它