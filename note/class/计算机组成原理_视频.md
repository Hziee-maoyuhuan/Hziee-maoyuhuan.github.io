# 计算机组成原理 视频

## 计算机的基本结构

### 电子计算机的兴起

-   历史知识:
    -   电子计算机之父 冯·诺伊曼
    -   世界上第一台通用电子计算机 ECIAC 1946.02.14 美国宾夕法尼亚大学
    -   冯·诺依曼对ENIAC的分析:ENIAC的开关和转插线只不过代表着一些数字信息,完全可以像受程序管理的数据一样存放于主存储器中  ("存储程序"的概念)
    -   存储程序式计算机 冯诺依曼结构计算机 EDVAC 实现存储程序概念,提升任务效率 采用二进制,简化逻辑线路
    -   第一台实用的存储程序式计算机 EDSAC
    -   UNIVAC 总统选举一举成名

### 冯诺依曼结构的要点

-   历史知识:
    -   冯诺依曼撰写的《关于EDVAC的报告草案》描述了冯诺依曼计算机结构
    -   草案论述了两个重要设计思想: 存储程序(而非开关连线) 二进制(而非十进制)
    -   草案明确了计算机的五个部分: 运算器 控制器 存储器 输入设备 输出设备
    -   4001-ROM只读存储器 4002-RAM随机存储器 4003-I/O移位寄存器  4004-CPU微处理器
-   冯诺依曼结构的要点:
    -   计算机五大组成部分
        -   CA 运算器
        -   CC 运算器
        -   M 存储器
        -   I 输入设备
        -   O 输出设备
    -   数据和程序以二进制代码不加区别存放在存储器中,存放位置由存储器的地址确定
        <img src="计算机组成原理 视频.assets/image-20201125161343578.png" alt="image-20201125161343578" style="zoom:50%;" />
    -   计算机在工作时能够自动从存储器中取出指令并加以执行
        -   计算机执行一条指令的主要步骤
            -   取指
            -   译码
            -   执行
            -   回写
        -   计算机结构简化模型 模型机
            -   分为存储器和CPU 之间由控制总线 地址总线和数据总线相连接
                ![image-20201125153956863](计算机组成原理 视频.assets/image-20201125153956863.png)
            -   存储器
                ![image-20201125154217038](计算机组成原理 视频.assets/image-20201125154217038.png)
            -   控制器
                ![image-20201125154311870](计算机组成原理 视频.assets/image-20201125154311870.png)
                ![image-20201125154404712](计算机组成原理 视频.assets/image-20201125154404712.png)
                ![image-20201125154431216](计算机组成原理 视频.assets/image-20201125154431216.png)
            -   运算器 主要分为算术运算和逻辑运算 通用寄存器传输数据通过内部总线
                ![image-20201125154628545](计算机组成原理 视频.assets/image-20201125154628545.png)
            -   模型机运转过程
                -   取指
                    -   控制器将指令的地址送往存储器
                    -   存储器按照给定的地址读出指令内容 送回控制器
                    -   步骤:
                        -   控制器发出信号将PC数据送到MAR中
                        -   MAR将地址送到地址总线 同时控制电路发出读数据信号 存储器读取信号
                        -   存储器通过地址译码器取出对应指令 反馈准备信号给控制电路并将数据存入数据总线
                        -   CPU将地址总线数据(指令)存入MDR 然后存入IR(指令寄存器)
                        -   将PC寄存器更新下一条指令的位置
                -   译码
                    -   控制器分析指令的操作性质
                    -   控制器向有关部件发出指令所需要的控制信号
                    -   步骤:
                        -   将IR指令寄存器中的数据(指令)送入指令译码器
                        -   控制电路发送相对应信号
                -   执行
                    -   控制器从通用寄存器或存储器中取出操作数
                    -   控制器命令运算器对操作数进行指令规定的运算
                    -   步骤:
                        -   取数据 类似译码取指过程,即从存储器中读取数据
                        -   根据指令进行操作
                -   回写
                    -   将运算结果写入通用寄存器或存储器
                    -   控制电路发出对应信号将ALU结果寄存器中的数据存储到对应位置
            -   输入输出设备
                ![image-20201125161655956](计算机组成原理 视频.assets/image-20201125161655956.png)
                -   输入
                    ![image-20201125161803726](计算机组成原理 视频.assets/image-20201125161803726.png)
                -   输出
                    ![image-20201125161856289](计算机组成原理 视频.assets/image-20201125161856289.png)
    -   现今计算机与冯诺依曼结构对比
        -   CPU -- CA + CC
        -   南桥 -- I/O输入输出
        -   现今计算机启动过程
            -   CPU经过北桥经过南桥从BIOS(一种只读存储器)中读取启动所需要的代码
            -   根据启动代码检查主板上的各部件
            -   GPU(显卡的图形处理单元) 也会参与数据处理工作 充当运算器和控制器
        -   现今计算机演化过程
            -   南北桥架构 南桥控制I/O 北桥连接CPU/主存/显卡等
            -   北桥集成到CPU中 主板上留下南桥 
            -   系统芯片SoC 将计算机或其他电子系统集成为单一芯片的继承电路
            -   摩尔定律: 约18个月性能翻一倍

## 指令系统体系结构

### 简单的计算机指令系统

-   指令分类 举例
    -   运算类指令 加/减/乘/除
        -   ADD R, M  将R寄存器中的内容与M存储器中的内容相加后存储R寄存器
    -   传送类指令 加载/存储
        -   LOAD R, M  将M存储器中的内容存储R寄存器
        -   STORE M, R  将R寄存器中的内容放入M存储器中
    -   转移类指令 跳转
        -   JMP L  无条件转向L处
-   指令格式
    -   每条指令等长 均为2个字节
    -   第一个字节的高四位为操作码
    -   第一个字节的第四位是寄存器号
    -   第二个字节是存储单元地址
-   标志寄存器
    ![image-20201125165901455](计算机组成原理 视频.assets/image-20201125165901455.png)
    -   flags寄存器中包含若干标志位 主要分为两大类
        -   状态标志 反映CPU的工作状态
        -   控制标志 对CPU运行起特定控制作用
-   指令指针寄存器IP
    -   理论上 16位宽寻址能力只有2^16=64k字节单元 实际上有20位宽 使用了段寄存器
        ![image-20201125170147550](计算机组成原理 视频.assets/image-20201125170147550.png)

### Intel 80386 

![image-20201125170547085](计算机组成原理 视频.assets/image-20201125170547085.png)

-   80x86系列中第一款32位微处理器 可以寻址4G内存空间
-   但是日后64位体系结构中 Intel提出的IA-64是独立于x86的一种新体系结构,不兼容IA-32
-   x86-64寄存器模型
    ![image-20201125170843925](计算机组成原理 视频.assets/image-20201125170843925.png)

-   x86指令简介

    -   指令主要类别

        -   运算类指令
            -   作用: 完成算术运算 提供运算结果调整,符号扩展等功能
                ![image-20201125185025086](计算机组成原理 视频.assets/image-20201125185025086.png)
            -   操作数限制: 目的操作数不能是立即数或CS寄存器 两个操作数不能同时为存储器操作数
        -   传送类指令
            -   作用: 把数据或地址传送到寄存器或者存储器单元中
                ![image-20201125184444242](计算机组成原理 视频.assets/image-20201125184444242.png)
        -   转移类指令
            -   作用: 改变你指令执行顺序
                ![image-20201125190509648](计算机组成原理 视频.assets/image-20201125190509648.png)
            -   说明: 根据是否有判断条件分为有条件/无条件 根据转移目标地址提供方式,分为直接转移和间接转移
        -   控制类指令
            -   作用: 控制CPU的功能 对标志位进行操作

    -   指令运行结果: 改变通用寄存器内容 改变存储单元内容 改变标志位 改变指令指针 该笔那外设端口等

    -   复杂x86指令

        -   串操作指令

            -   作用:

                -   对存储器中的数据传进行每次一个元素的操作
                -   串的基本单位是字节或字(即"一个元素")
                -   串长度可以到64k

            -   分类:

                ![image-20201125192754540](计算机组成原理 视频.assets/image-20201125192754540.png)

                -   共5条串操作指令
                -   另有三种重复前缀,与串操作指令配合使用
                
            -   举例:

                -   MOVSB 字节串传送
                    -   格式: MOVSB
                    -   操作: 在存储器中将指定位置的一个字节单元传送到另一个指定的位置
                -   REP前缀 无条件重复
                    -   格式: REP 串操作指令
                    -   操作: 当CX不为0时,重复执行串操作指令

            -   特性:

                -   具有隐含操作数 (DS:SI ES:DI CX等)
                -   方向标志作用


### MIPS体系结构

-   历史: 
    -   MIPS设计者 约翰·亨尼西 担任过斯坦福大学校长 引领精简指令系统潮流
    -   如今MIPS在计算机上不使用 但是在数字电视,机顶盒等领域仍在使用
        ![image-20201125213519254](计算机组成原理 视频.assets/image-20201125213519254.png)
-   关注点
    -   减少指令类型
    -   降低指令复杂度
    -   一个简单更快的CPU
-   特点
    -   固定指令长度 32bit,即1word 简化从存储器取指令
    -   简单的寻址模式 简化了从存储器取操作数
    -   指令数量少 指令功能简单 简单指令的执行过程
    -   只有LOAD和STORE指令可以访问存储器
    -   指令简洁统一
    -   导致编程困难 需要优秀的编译器支持
    -   MIPS寄存器使用$进行编号
    -   MIPS寄存器有规定的编号 有规定的用户 一共32个 每个32位
    -   指令限制位数 不像x86可以扩展
-   简介
    -   MIPS指令基本格式
        ![image-20201125233141163](计算机组成原理 视频.assets/image-20201125233141163.png)

        -   基本格式分类: R型 寄存器 / I型 立即数 / J型 无条件转移

            -   R型指令 寄存器指令
                ![image-20201127163627840](计算机组成原理 视频.assets/image-20201127163627840.png)

                -   包含了6个域

                    -   2个6bit域 可以表示0~63的数 (opcode funct)

                        -   opcode域 用于指定指令的类型 对于所有R型指令 该域值均为0
                        -   funct域 域opcode域结合,精确指定指令类型

                    -   4个5bit域 可以表示0~31的数 (rs rt rd) 对应32个寄存器 (shamt) 对应移位位数

                        -   rs域 通常用于指定第一个源操作数所在寄存器编号
                        -   rt域 通常用于指定第二个源操作数所在寄存器编号
                        -   rd域 通常用于指定目的操作数(保存运算结果)寄存器编号

                        -   shamt域 表示移位操作位数 对于非移位指令 该域为0

            -   I型指令 存在立即数指令
                ![image-20201127165801814](计算机组成原理 视频.assets/image-20201127165801814.png)

                -   包含了5个域
                    -   一个6bit域 可以表示0~63的数 (opcode)
                    -   两个5bit域 可以表示-~31的数 (rs rt)
                    -   一个16bit域 可以表示0~65535的数 (immediate)
                        -   立即数对访存指令 可以满足方寸地址偏移量需求
                        -   立即数对运算指令 大多数情况下可以符合要求 该域使用补码存储

            -   J型指令 非条件分支指令
                ![image-20201127165849486](计算机组成原理 视频.assets/image-20201127165849486.png)

                -   包含了2个域
                    ![image-20201127170028032](计算机组成原理 视频.assets/image-20201127170028032.png)
                    -   一个6bit域 (opcode)
                    -   一个26bit域 (address)
                        -   表示可以是2^28byte 因为末2位为0
                        -   如何到达更远的目标地址
                            -   多次调用J指令
                            -   使用jr rs指令

        -   功能分类: 运算指令 / 访存指令 / 分支指令

            -   运算指令
            -   访存指令
            -   分支指令 (branch) 改变控制流 判断reg1和reg2是否相等 相等/不等 则进行偏移
                ![image-20201127165738698](计算机组成原理 视频.assets/image-20201127165738698.png)
                -   条件分支 根据比较的结果改变控制流
                -   非条件分支 无条件改变控制流
                -   目标地址范围 
                    -   16位可以表示当前基准前后2^15bytes MIPS指令长度32bit 末2位为0
                    -   所以可以表示范围是2^17bytes 前后128K

## 算术逻辑单元

### 算术运算和逻辑运算

-   算术运算
    ![image-20201127171007042](计算机组成原理 视频.assets/image-20201127171007042.png)
    -   两个32位数加法/减法 结果是一个32位数
    -   检查加减法结果是否溢出
-   逻辑运算
    ![image-20201127171207513](计算机组成原理 视频.assets/image-20201127171207513.png)
    -   两个32位数的 与/或/非操作 结果是一个32位数

### 门电路的基本原理

-   晶体管 MOS 金属-氧化物半导体
    -   N型MOS管 高电平导通 低电平不导通
    -   P型MOS管 高电平不导通 低电平导通
    -   CMOS 由NMOS和PMOS构成的互补型MOS集成电路
-   简单门电路
    -   与门 同时成立结果才成立
        -   工作原理 (与非门) 可以使用与非门和非门进行连接实现与门功能
            ![image-20201127171858102](计算机组成原理 视频.assets/image-20201127171858102.png)
    -   或门 有一个成立结果就成立
    -   非门 入1出0 入0出1
        -   工作原理
            ![image-20201127171816179](计算机组成原理 视频.assets/image-20201127171816179.png)
    -   异或门 同0异1

### 寄存器的基本原理

-   D触发器
    ![image-20201127172412160](计算机组成原理 视频.assets/image-20201127172412160.png)
    ![image-20201127173004879](计算机组成原理 视频.assets/image-20201127173004879.png)
    -   具有存储信息能力的基本单元
    -   由若干逻辑门构成 多种实现方式
    -   一个数据输入 一个时钟信号 一个数据输出
    -   Clock时钟信号上升沿时,采样输入D送到Q 其他时间Q值不变
    -   在上升沿前后需要一段时间进行稳定

-   寄存器
    -   内部结构 由D触发器组成 使用多个触发器可以做成一个多位寄存器
-   包含多种功能的运算单元 ALU
    -   32位输入的两个数分别传送到不同的门上 结果为各个1位输出的总和
        ![image-20201127181552055](计算机组成原理 视频.assets/image-20201127181552055.png)

### 加法和减法的实现

-   半加器 将两个一位二进制数相加
    ![image-20201127181947852](计算机组成原理 视频.assets/image-20201127181947852.png)
-   全加器 由两个半加器构成
    ![image-20201127182121384](计算机组成原理 视频.assets/image-20201127182121384.png)
-   加法实现 四位加法器 由全加器组合而成
    ![image-20201127182222944](计算机组成原理 视频.assets/image-20201127182222944.png)
-   溢出处理
    -   溢出
        -   运算结果超出了正常表示的范围
        -   仅针对有符号数运算 也就是说数值部分可能产生了进位加到了符号位
        -   判断方法: 最高位的进位输入不等于最高位进位输出 则表示有溢出 使用异或门
            ![image-20201127182721150](计算机组成原理 视频.assets/image-20201127182721150.png)
        -   MIPS使用不同的指令处理溢出 x86使用OF标志位判断是否溢出
    -   进位
    -   区别  有进位不一定有溢出 有溢出不一定有进位
        ![image-20201127182559351](计算机组成原理 视频.assets/image-20201127182559351.png)
-   减法实现 转换位加法运算
    -   减去一个数,等于加上这个数的相反数 计算机中使用补码存储 故相反数结果是按位取反,末尾加1
        -   计算机中 一个数和它的按位取反的结果相加,结果是全一也就是-1 故加1
-   加法器 兼 减法器的实现 控制sub-mode信号 灵活实现末尾加一的功能jia'yi
    ![image-20201127183222627](计算机组成原理 视频.assets/image-20201127183222627.png)

### 加法器的优化

-   行波进位加法器 RCA
    -   特点
        -   低位全加器输出进位连接到高位全加器的输入进位
    -   优点  电路布局简单 设计方便
    -   缺点  高位运算需要等待低位计算
    -   关键路径(延迟最长的路径):n位->2n+1个门延时(线也延时,相比门延时忽略不计)
-   超前进位加法器 CLA
    -   优化思路:
        -   高位需要等待低位输入 可以提前计算出进位输出信号
            ![image-20201127184003680](计算机组成原理 视频.assets/image-20201127184003680.png)
            ![image-20201127184114798](计算机组成原理 视频.assets/image-20201127184114798.png)
            ![image-20201127184330109](计算机组成原理 视频.assets/image-20201127184330109.png)
    -   模型展示:
        ![image-20201127184438567](计算机组成原理 视频.assets/image-20201127184438567.png)
    -   特点:
        -   相比RCA,CLA延时低 四位加法器只需要三级门延迟加最后一级门延迟 RCA->9级
    -   优点  延时低 与位数无关
    -   缺点  实际电路过于复杂 难以实现
-   通常使用多个小规模的超前进位加法器拼接而成 这样不会太影响CPU性能
    ![image-20201127184830524](计算机组成原理 视频.assets/image-20201127184830524.png)

## 乘法器和除法器

### 乘法器

-   乘法运算过程
    -   对计算机而言 只有0和1
        -   如果当前参与运算乘数位为1则将被乘数放在对应位置
        -   如果当前参与运算乘数位为0则将0放在对应位置
    -   十进制和二进制的选择
        -   电子管适合表示只有两个数值的系统 即二进制
        -   二进制可以大幅简化乘法和除法
        -   十进制适合人使用 输入输出设备需要承担二进制和十进制进行转换的工作
    -   判断是1还是0 加到结果并将被乘数左移1位
-   乘法器的实现
    ![image-20201127190341046](计算机组成原理 视频.assets/image-20201127190341046.png)
    ![image-20201127200748608](计算机组成原理 视频.assets/image-20201127200748608.png)
    -   从乘数中取出末尾进行判断 如果是1则将被乘数加到结果中 如果是0则不进行操作
    -   乘数右移 被乘数左移
    -   进行下一次操作 直到次数等于乘数长度(也就是乘数全零)
-   乘法器的优化
    ![image-20201127201435316](计算机组成原理 视频.assets/image-20201127201435316.png)
    -   时钟上升沿到来时寄存器根据输入改变内容
    -   同时8位全加器进行运算 生成结果 但是结果暂未输入到结果中 等待下一个时钟上升沿
    -   寄存器和全加器都可以实现简化 使用更加小的寄存器和4位的全加器
        ![image-20201127202857293](计算机组成原理 视频.assets/image-20201127202857293.png)
        -   被乘数寄存器8位宽 但是使用的只有4位 -> 移除左移功能 缩减到4位
        -   乘数每次减少一位 造成浪费 -> 不需要设置寄存器 直接取出结果的末尾 (控制逻辑位是结果寄存器的末位)
        -   加法器是8位 可以简化成4位 -> 缩减到4位 结果存入到结果存储的高四位 存储结束结果右移
        -   一开始乘积寄存器只有4位造成浪费 -> 增加右移功能 保持8位位宽 起初高四位放结果(全0) 低四位放乘数

### 除法器

-   除法器运算过程
    -   理论分析
        -   和十进制除进行对比
        -   计算机中的实现
            ![image-20201127203527051](计算机组成原理 视频.assets/image-20201127203527051.png)
-   除法器的实现
    -   一个32位除法器的步骤介绍
        ![image-20201127203722271](计算机组成原理 视频.assets/image-20201127203722271.png)
    -   四位除法器工作需求
        ![image-20201127204053460](计算机组成原理 视频.assets/image-20201127204053460.png)
        -   8位ALU需要同时支持加法和减法运算 (通常使用的是减法 如果需要回退则需要使用加法)
    -   除法器的工作流程
        -   初始化
            ![image-20201127235449743](计算机组成原理 视频.assets/image-20201127235449743.png)
        -   如果结果小于0则进行回退(说明不能这么操作) 也就是加上刚刚那个数
            ![image-20201127235930755](计算机组成原理 视频.assets/image-20201127235930755.png)
        -   如果结果大于0则继续进行操作(说明这样做可以) 商左移末位置1
            ![image-20201128001205621](计算机组成原理 视频.assets/image-20201128001205621.png)
        -   除数进行右移
            ![image-20201128000031947](计算机组成原理 视频.assets/image-20201128000031947.png)
        -   检查是否最后一次循环 通过控制逻辑进行判断
-   除法器的优化
    -   存在的问题 32位为例
        -   除数寄存器实际只用了一半 移位的时候不丢失
            -   除数寄存器设置位32位 不设置移位
        -   商寄存器一开始是空的 后面才填满
            -   取消商寄存器 放置于别的地方
        -   ALU为64位 
            -   让有效位进行运算 也就是仅使用32位ALU
        -   余数寄存器一开始是满的 有实际意义的位从左至右逐渐减少
            -   保持64位 高32位存放数据 支持左右移功能 左移丢弃高位 
            -   结束的时候 商寄存器占余数寄存器的低32位
        -   因为无法判断减法操作的结果所以流程上无法进行优化

## 单周期处理器

### 处理器设计的主要步骤

-   处理器的设计步骤
    -   分析指令系统 得出对数据通路(数据需要的硬件结构)的需求 (硬件人员和软件人员商议所得)
    -   为数据通路选择合适的组件
    -   连接组件建立数据通路
    -   分析每条指令的实现,确定控制信号
    -   集成控制信号,形成完整控制逻辑(控制器)
-   使用MIPS指令系统哦的简化版本进行概述
    -   无符号数加法/减法:addu/subu 立即数的逻辑或:ori 装载.存储一个字(32位):lw/sw 条件分支:beq
    -   指令位域的分解 需要一个可读的存储器
        ![image-20201128154001242](计算机组成原理 视频.assets/image-20201128154001242.png)
    -   指令操作
        -   运算指令
            -   寄存器堆: 一组存放数据的32位通用寄存器(32个) 
            -   运算时 需要同时读取两个寄存器的内容 存储于另一个寄存器
            -   立即数需要扩展成32位(0扩展)
            -   需要提供加/减/逻辑或
        -   访存指令
            -   能够可读可写的32位寄存器
            -   立即数需要扩展成32位(符号扩展)
-   指令系统的需求
    -   算术逻辑单元
        -   运算类型: 加 减 逻辑或
        -   操作数: 2个32位数,来自寄存器或者扩展后的立即数
    -   立即数扩展部件
        -   将一个16位数扩展成32位数
        -   扩展方式: 0扩展 符号扩展
    -   程序计数器PC
        -   一个32位寄存器 具有时钟输入
        -   支持两种加法: 加4(移动到下一条指令) 或者 加一个立即数(跳转到指定的指令位置)
    -   寄存器堆
        ![image-20201128160215648](计算机组成原理 视频.assets/image-20201128160215648.png)
        -   每个寄存器32位宽,共32个
        -   支持读操作和写操作 (读rs和rt 写rt或rd) 称为"两读一写"寄存器堆
    -   存储器
        ![image-20201128160406999](计算机组成原理 视频.assets/image-20201128160406999.png)
        -   一个只读的指令存储器  地址和数据均为32位
        -   一个可读可写的数据存储器 地址和数据均为32位
        -   冯诺依曼的思想:设一个可读写的存储器 上述两个对应实际CPU中的指令和数据高速缓存(Cache)

### 数据通路的建立

-   基本原则
    -   根据指令需求, 连接组件, 建立数据通路
-   指令需求
    -   所有指令共同需求 IFU 取指单元
        ![](计算机组成原理 视频.assets/image-20201128161556529.png)
        -   取指令
            -   程序计数器PC的内容是指令的地址
            -   用PC的内容作为地址,访问指令存储器获得指令编码
        -   更新程序计数器
            -   顺序执行: PC <- PC + 4 也就是指向下一条指令
            -   发生分支: PC <- 分支目标地址
        -   生成模块IFU
            -   只需要时钟信号和选择信号的输入就可以产生一条指令的二进制编码
            -   只要初始化后就可以持续工作

### 不同指令不同需求

-   加减法指令需求
    ![image-20201128162208907](计算机组成原理 视频.assets/image-20201128162208907.png)
    -   需要使用 寄存器堆和可加减的ALU
-   逻辑运算指令需求
    -   使用前面的寄存器堆的问题
        -   目的寄存器为rt而非rd
        -   立即数是ALU的输入
        -   立即数只有16位 寄存器需要32位
    -   解决方法: 增加二选一数据选择器和零扩展部件
        ![image-20201128170551743](计算机组成原理 视频.assets/image-20201128170551743.png)
-   访存指令需求
    -   使用之前的寄存器的问题
        -   无法进行符号扩展
        -   如何装载数据
    -   解决方案: 将原有的零扩展增加符号扩展功能 加入数据存储器
        ![image-20201128171057120](计算机组成原理 视频.assets/image-20201128171057120.png)
        ![image-20201128171322342](计算机组成原理 视频.assets/image-20201128171322342.png)
-   不同指令的控制信号 (对简化后的指令进行讲解)
    ![image-20201128173840602](计算机组成原理_视频.assets/image-20201128173840602.png)
    -   运算指令控制信号 (addu rd,rs, rt)
        -   从指令存储器中取回指令 Instruction = MEM[PC]
            -   从指令存储器中取回指令 所有指令都需要 在IFU完成 
        -   指令指定的操作 通过控制信号
            J型指令 addu/subu![image-20201128174515950](计算机组成原理_视频.assets/image-20201128174515950.png)
            连入对应的输入端![image-20201128174623726](计算机组成原理_视频.assets/image-20201128174623726.png)
            设置信号值
            ![image-20201128175022956](计算机组成原理_视频.assets/image-20201128175022956.png)
            I型指令 ori![image-20201128184840700](计算机组成原理_视频.assets/image-20201128184840700.png)
        -   计算下一条指令的地址
            -   当前寄存器加4(顺序执行的情况)
    -   访存指令控制信号
        -   取指和下一条指令的操作同上 不赘述
        -    指令指定的操作 (如下图)
            I型指令![image-20201128185406963](计算机组成原理_视频.assets/image-20201128185406963.png)
            ![image-20201128185449754](计算机组成原理_视频.assets/image-20201128185449754.png)
            ![image-20201128185716640](计算机组成原理_视频.assets/image-20201128185716640.png)
            ![image-20201128185817432](计算机组成原理_视频.assets/image-20201128185817432.png)
    -   分支指令控制信号
        -   C语言MIPS对分支的表示区别
            ![image-20201128190010176](计算机组成原理_视频.assets/image-20201128190010176.png)
        -   从指令存储器中取出指令 同上
        -   判断条件是否成立
            -   需要新增的标志位 根据zero标志位是否成立判断IFU下一条指令的去向![image-20201128190405137](计算机组成原理_视频.assets/image-20201128190405137.png)
            -   对应的信号![image-20201128190716787](计算机组成原理_视频.assets/image-20201128190716787.png)
        -   计算下一条指令的地址 和其他指令不一样
            -   分析过程 列表
                ![image-20201128191018967](计算机组成原理_视频.assets/image-20201128191018967.png)
            -   修改过程 使用与门 更改IFU
                ![image-20201128191110472](计算机组成原理_视频.assets/image-20201128191110472.png)
                ![image-20201128191213612](计算机组成原理_视频.assets/image-20201128191213612.png)
                ![image-20201128191426559](计算机组成原理_视频.assets/image-20201128191426559.png)

### 控制信号的集成

-   现有指令所需的控制信号 形成完整的数据逻辑
    -   控制逻辑与数据通路
        ![image-20201128191840529](计算机组成原理_视频.assets/image-20201128191840529.png)
    -   通过罗列对应信号 可以描述控制信号和对应指令
        ![image-20201128192014208](计算机组成原理_视频.assets/image-20201128192014208.png)
    -   举例
        -   ![image-20201128192330820](计算机组成原理_视频.assets/image-20201128192330820.png)
        -   ![image-20201128192455841](计算机组成原理_视频.assets/image-20201128192455841.png)
        -   控制逻辑![image-20201128192600338](计算机组成原理_视频.assets/image-20201128192600338.png)
    -   不需要通过人为智力因素对其进行判断 交由计算机自己执行
-   单周期处理器到此便可以使用了

## 流水线处理器

### 流水线的基本原理

-   介绍
    -   一种生产模式 对效率有极大提升 处理器中也有类似过程
    -   一个工序在工作的时候,其他工序等待 这种情况可以提升效率
-   单周期处理器分析 
    -   MIPS指令执行主要步骤: 取指 译码 执行 访存 回写
        ![image-20201130152525546](计算机组成原理_视频.assets/image-20201130152525546.png)
        -   取出的指令在程序执行的独立的过程中需要保持稳定 所以需要保存下来 (蓝色条表示寄存器)
            ![image-20201130152753424](计算机组成原理_视频.assets/image-20201130152753424.png)
            -   随时钟上升沿来临,取指的结果会被分割并保存到各个寄存器中,以供读取
            -   时钟非上升沿,寄存器中的数据稳定不改变
-   流水线处理器性能分析
    ![image-20201130153234292](计算机组成原理_视频.assets/image-20201130153234292.png)
    -   理论有五倍性能提升 但是因为插入的寄存器本身,性能提升可能没这么大
    -   但看某一条指令的执行,反而因为插入寄存器而变慢
        ![image-20201130153512595](计算机组成原理_视频.assets/image-20201130153512595.png)
        -   提升性能是因为各个部件可以并行操作,提高指令吞吐率而非单指令执行速度

### 流水线的优化

-   流水线分析
    ![image-20201130153845492](计算机组成原理_视频.assets/image-20201130153845492.png)
    -   理想化情况,多少个工序,从单周期转换成流水线就可以有几倍效率提升
-   遇到问题
    -   流水线不平衡性: 流水线时钟周期:以步骤中用时最长的步骤时长为周期
        -   总体看来 不平衡流水线工作效率低了许多
        -   单独来看 流水线方式花的时间更加长
    -   每一级操作花费时间尽可能相等
        -   将原来的硬件资源分块,以达到各个操作等长时间的结果
            ![image-20201130154542687](计算机组成原理_视频.assets/image-20201130154542687.png)
-   超级流水线 技术
    -   介绍
        -   将流水线切分更加细增加深度
        -   可以达到更高的效率,提升时钟频率,提高指令吞吐率
    -   问题
        -   并不是级数越多越好 时钟频率提高并不意味性能好 (CPU主频大战)
        -   越多级流水线,单条指令延时增加,寄存器延迟所占比例变大
        -   填满流水线的指令更多 操作之间更加复杂
    -   现实情况
        -   MIPS处理器,奔腾处理器 实现流水线
        -   x86 没有实现 并且比MIPS复杂多,难以使用流水线切分
        -   目前CPU流水线深度大概为15级左右
            ![image-20201130160234407](计算机组成原理_视频.assets/image-20201130160234407.png)

### 超标量流水线

-   介绍
    -   通常,具有两条或者两条以上并行工作的流水线结构称为超标量流水线
    -   之前的流水线称为 标量流水线
    -   使用超标量结构的处理器称为超标量处理器 (多发射结构)
        -   奔腾微处理器是第一款超标量x86CPU
            ![image-20201130162723185](计算机组成原理_视频.assets/image-20201130162723185.png)
        -   第一台超级计算机(CDC6600 超标量计算机 但不是流水线工作方式)
-   超标量流水线和标量流水线
    -   单周期到标量流水线: 时间并行性进行优化,主要对现有硬件进行切分,将串行改成并行
    -   标量到超标量流水线: 空间并行性的优化,需要成倍增加硬件资源
    -   现在的CPU
        ![image-20201130165638105](计算机组成原理_视频.assets/image-20201130165638105.png)

### 流水线冒险

-   含义:
    -   阻止下一条指令在下一个时钟周期开始执行的情况
-   分类
    -   结构冒险 所需硬件部件正在为之前的指令工作,无法为本指令工作
        -   同一时刻 不同操作需要 同一个部件
        -   如果指令和数据在同一个存储器中,则不能同时读存储器
        -   解决方案:
            1.  流水线停顿stall,同时产生空泡bubble 停顿一个周期(延后)
                ![image-20201130171945041](计算机组成原理_视频.assets/image-20201130171945041.png)
            2.  
    -   数据冒险 所需数据正在使用,需要等待之前的指令完成数据读写
    -   结构冒险 需要根据之前指令结果决定下一步行为 而前面的结果没有产生